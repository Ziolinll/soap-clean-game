<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>å—åƒ‘æ°´æ™¶æ·¨åŒ–å¤§ä½œæˆ°</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@500;900&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #2c3e50;
            font-family: 'Noto Sans TC', sans-serif;
            overflow: hidden; /* é˜²æ­¢æ²å‹• */
            touch-action: none; /* é˜²æ­¢æ‰‹æ©Ÿè§¸æ§æ™‚ç•«é¢æ²å‹• */
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background: url('9097929.jpg') no-repeat center center / cover;
        }

        canvas {
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            max-width: 100%;
            max-height: 100%;
        }

        .ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* è®“é»æ“Šç©¿é€åˆ° Canvas */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        .score-board {
            color: #13555e;
            font-size: 20px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
            display: flex;
            justify-content: space-between;
            width: 100%;
            max-width: 800px;
            margin: 0 auto;
        }

        /* å½ˆå‡ºè¦–çª—æ¨£å¼ */
        .modal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 30px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            pointer-events: auto;
            display: none; /* é è¨­éš±è— */
            width: 80%;
            max-width: 400px;
        }

        .modal h1 {
            color: #e67e22; /* å—åƒ‘æ°´æ™¶è‚¥çš‚çš„ç¶“å…¸æ©˜è‰² */
            margin: 0 0 10px 0;
            font-size: 28px;
        }

        .modal p {
            color: #333;
            font-size: 18px;
            margin: 10px 0;
        }

        .modal .big-score {
            font-size: 48px;
            font-weight: 900;
            color: #2980b9;
            margin: 10px 0;
        }

        .btn {
            background: #e67e22;
            color: white;
            border: none;
            padding: 12px 30px;
            font-size: 20px;
            border-radius: 50px;
            cursor: pointer;
            margin-top: 15px;
            transition: transform 0.1s;
            font-family: 'Noto Sans TC', sans-serif;
            font-weight: bold;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
        }

        .btn:active {
            transform: scale(0.95);
        }
        
        .btn-copy {
            background: #3498db;
            font-size: 16px;
            padding: 8px 20px;
            margin-top: 10px;
        }

        /* è¼‰å…¥ç•«é¢ */
        #start-screen {
            display: block;
        }

        /* ===== RWDï¼šå¹³æ¿ä»¥ä¸‹ ===== */
@media (max-width: 768px) {
    .ui-layer {
        padding: 12px;
    }

    .score-board {
        font-size: 16px;
        max-width: 100%;
        padding: 4px 8px;
    }

    .modal {
        width: 90%;
        padding: 20px;
    }

    .modal h1 {
        font-size: 22px;
    }

    .modal p {
        font-size: 16px;
    }

    .modal .big-score {
        font-size: 36px;
    }

    .btn {
        font-size: 18px;
        padding: 10px 24px;
    }

    .btn-copy {
        font-size: 14px;
        padding: 6px 18px;
    }
}

/* ===== RWDï¼šæ‰‹æ©Ÿçª„è¢å¹• ===== */
@media (max-width: 480px) {
    .ui-layer {
        padding: 8px;
    }

    .score-board {
        font-size: 14px;
        flex-direction: column;
        align-items: flex-start;
        gap: 2px;
    }

    .modal {
        width: 92%;
        padding: 16px;
    }

    .modal h1 {
        font-size: 20px;
    }

    .modal p {
        font-size: 14px;
    }

    .modal .big-score {
        font-size: 30px;
    }

    .btn {
        font-size: 16px;
        padding: 8px 20px;
    }
}

    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>

    <!-- UI å±¤ -->
    <div class="ui-layer">
        <div class="score-board">
            <span id="scoreDisplay">åˆ†æ•¸: 0</span>
            <span id="levelDisplay">é—œå¡: 1/5</span>
            <span id="livesDisplay">ç”Ÿå‘½: â¤ï¸â¤ï¸â¤ï¸</span>
        </div>
    </div>

    <!-- é–‹å§‹ç•«é¢ -->
    <div id="start-screen" class="modal">
        <h1>å—åƒ‘æ°´æ™¶<br>æ·¨åŒ–å¤§ä½œæˆ°</h1>
        <p>æ»‘å‹•æ‰‹æŒ‡æˆ–æ»‘é¼ æ§åˆ¶è‚¥çš‚</p>
        <p>æ¶ˆæ»…æ‰€æœ‰ç—…æ¯’ç£šå¡Šï¼</p>
        <button class="btn" onclick="startGame()">é–‹å§‹æ·¨åŒ–</button>
    </div>

    <!-- éŠæˆ²çµæŸ/é€šé—œç•«é¢ -->
    <div id="end-screen" class="modal">
        <h1 id="end-title">éŠæˆ²çµæŸ</h1>
        <p>æœ¬æ¬¡æ·¨åŒ–åˆ†æ•¸</p>
        <div class="big-score" id="final-score">0</div>
        <button class="btn btn-copy" onclick="copyScore()">è¤‡è£½æˆç¸¾ç•™è¨€</button>
        <br>
        <button class="btn" onclick="location.reload()">å†ç©ä¸€æ¬¡</button>
    </div>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    // éŠæˆ²ç‹€æ…‹
    let globalScale = 1;
    let gameRunning = false;
    let score = 0;
    let lives = 3;
    let level = 1;
    const maxLevels = 5;

    // è¼‰å…¥çƒçš„åœ–ç‰‡
    const ballImage = new Image();
    // é€™è£¡è¨­å®šåœ–ç‰‡è·¯å¾‘ï¼Œè«‹ç¢ºä¿åœ–ç‰‡æª”åç‚º 'å—åƒ‘æ°´æ™¶.png' ä¸¦ä¸”åœ¨åŒä¸€ç›®éŒ„ä¸‹
    ballImage.src = 'å—åƒ‘æ°´æ™¶.png'; 
    // åŠ å…¥éŒ¯èª¤è™•ç†ï¼Œå¦‚æœåœ–ç‰‡æ²’è¼‰å…¥ï¼Œæœƒé¡¯ç¤ºé è¨­çš„åœ“å½¢
    let imageLoaded = false;
let ballImgRatio = 1; // åŠ é€™è¡Œï¼ˆæ–°ï¼‰

ballImage.onload = function () {
    imageLoaded = true;

    // ä¸‹é¢ 3 è¡Œæ˜¯æ–°å¢çš„ï¼ˆæ–°ï¼‰
    const w = ballImage.naturalWidth || ballImage.width;
    const h = ballImage.naturalHeight || ballImage.height;
    ballImgRatio = w / h;  // è¨˜éŒ„åœ–ç‰‡æ¯”ä¾‹
};

    // éŸ¿æ‡‰å¼ Canvas è¨­å®š
function resizeCanvas() {
    const vw = window.innerWidth;
    const vh = window.innerHeight;

    canvas.width = vw;
    canvas.height = vh;

    // === å…¨éŠæˆ²çµ±ä¸€ç¸®æ”¾æ¯”ä¾‹ ===
    // åŸºæº–ç•«é¢ï¼ˆä½ å–œæ­¡å¯ä»¥æ”¹æ‰ï¼‰
    const baseWidth = 414;   // iPhone å¸¸è¦‹å¯¬åº¦
    const baseHeight = 736;  // å…¸å‹ç›´å‘æ¯”ä¾‹

    const scaleX = vw / baseWidth;
    const scaleY = vh / baseHeight;

    // å–è¼ƒå°çš„é‚£å€‹ï¼Œé¿å…è¶…å‡ºç•«é¢
    globalScale = Math.min(scaleX, scaleY);

    // === å¥—ç”¨åˆ°æ¿å­ ===
    paddle.width = 200 * globalScale;
    paddle.height = 15 * globalScale;

    // æ¿å­ä½ç½®ä¿æŒåœ¨åº•éƒ¨
    paddle.y = canvas.height - 40 * globalScale;

    // === å¥—ç”¨åˆ°çƒ ===
    ball.size = 20 * globalScale;

    // === å¥—ç”¨åˆ°ç—…æ¯’ç£šå¡Š ===
    brickConfig.height = 30 * globalScale;
    brickConfig.padding = 10 * globalScale;
    brickConfig.offsetTop = 60 * globalScale;

    initBricks();
    resetBall();
}

    // çƒé«”è¨­å®š
    const ball = {
        x: 0,
        y: 0,
        size: 20, // ç¨å¾®åŠ å¤§åŠå¾‘è®“åœ–ç‰‡çœ‹æ¸…æ¥šä¸€é» (åŸæœ¬æ˜¯10)
        speed: 3, 
        dx: 4,
        dy: -4,
        color: 'rgba(230, 126, 34, 0.9)'
    };

    // æ¿å­è¨­å®š
    const paddle = {
        width: 200,
        height: 15,
        x: 0,
        y: canvas.height - 300, 
        color: '#312aa6',
        speed: 8
    };

    // ç£šå¡Šè¨­å®š
    const brickConfig = {
        rowCount: 3,
        columnCount: 5,
        width: 0, 
        height: 30,
        padding: 10,
        offsetTop: 60,
        offsetLeft: 30,
        colors: ['#2ecc71', '#9b59b6', '#e74c3c', '#f1c40f', '#34495e']
    };

    let bricks = [];
    let brickOffsetX = 0;        // ç›®å‰æ°´å¹³åç§»é‡
    let brickDirection = 1;      // 1 å¾€å³ã€-1 å¾€å·¦
    const brickMaxOffset = 40;   // å·¦å³æœ€å¤šç§»å‹•è·é›¢ï¼ˆå¯ä»¥è‡ªå·±èª¿ï¼‰
    const brickMoveSpeed = 1.2;  // æ¯ç¦ç§»å‹•å¤šå°‘ï¼ˆè¶Šå¤§è¶Šå¿«ï¼‰

    // åˆå§‹åŒ–ç£šå¡Š
function initBricks() {
    bricks = [];

    // å¦‚æœä½ æœ‰ç—…æ¯’å·¦å³ç§»å‹•ï¼Œé€™å…©è¡Œå¯ä»¥ç•™è‘—ï¼š
    // brickOffsetX = 0;
    // brickDirection = 1;

    // æ¯ä¸€é—œåˆ—æ•¸ä¸€æ¨£ç”¨åŸæœ¬çš„
    brickConfig.rowCount = 2 + level;

    // === é€™è£¡é–‹å§‹æ˜¯ã€Œé›»è…¦å¤šä¸€é»ç—…æ¯’ã€æ‰‹æ©Ÿå°‘ä¸€é»ã€çš„æ ¸å¿ƒ ===
    let maxColumns;      // é€™é—œæœ€å¤šå¹¾è¡Œç—…æ¯’
    let baseBrickWidth;  // é æœŸå–®ä¸€ç£šçš„ã€Œç›®æ¨™å¯¬åº¦ã€

    if (canvas.width >= 1200) {
        // æ¡Œæ©Ÿï¼šç•«é¢å¾ˆå¯¬ â†’ å¤šä¸€é»ç—…æ¯’ã€æ¯é¡†ç¨å¾®çª„
        maxColumns = 14;
        baseBrickWidth = 55;
    } else if (canvas.width >= 768) {
        // å¹³æ¿ï¼šä¸­é–“å€¼
        maxColumns = 11;
        baseBrickWidth = 60;
    } else {
        // æ‰‹æ©Ÿï¼šå°‘ä¸€é»ç—…æ¯’ï¼Œä¸è¦å¤ªæ“ 
        maxColumns = 8;
        baseBrickWidth = 70;
    }

    // ç”¨è¢å¹•å¯¬åº¦ / é æœŸå¯¬åº¦ï¼Œç®—å‡ºç†è«–ä¸Šå¯ä»¥æ”¾å¹¾é¡†
    brickConfig.columnCount = Math.floor(
        (canvas.width - 40 * globalScale) / (baseBrickWidth * globalScale + brickConfig.padding)
    );

    // é™åˆ¶ä¸€å€‹åˆç†ç¯„åœï¼Œé¿å…å¤ªå°‘æˆ–å¤ªå¤š
    brickConfig.columnCount = Math.max(4, Math.min(brickConfig.columnCount, maxColumns));

    // ä¾ç…§ç®—å‡ºä¾†çš„ columnCount é‡æ–°å¹³å‡æ’ç‰ˆï¼Œè®“æ•´æ’å‰›å¥½é‹ªæ»¿
    let totalPadding = (brickConfig.columnCount + 1) * brickConfig.padding;
    brickConfig.width = (canvas.width - totalPadding) / brickConfig.columnCount;
    brickConfig.offsetLeft = brickConfig.padding;

    // === å»ºç«‹ç£šå¡Šé™£åˆ— ===
    for (let c = 0; c < brickConfig.columnCount; c++) {
        bricks[c] = [];
        for (let r = 0; r < brickConfig.rowCount; r++) {
            let status = 1;
            if (level >= 3 && Math.random() > 0.8) status = 2;

            bricks[c][r] = {
                x: 0,
                y: 0,
                status: status,
                color: brickConfig.colors[r % brickConfig.colors.length]
            };
        }
    }
}


    // ç¹ªè£½çƒ (å·²ä¿®æ”¹ç‚ºç¹ªè£½åœ–ç‰‡)
function drawBall() {
    ctx.imageSmoothingEnabled = false; // è®“åœ–ç‰‡æ›´æ¸…æ¥š

    if (imageLoaded) {

        const scale = 3; // â† ä½ æƒ³æ”¾å¤šå¤§èª¿é€™è£¡
        const targetHeight = ball.size * 2 * scale;
        const targetWidth  = targetHeight * ballImgRatio;

        const drawX = ball.x - targetWidth / 2;
        const drawY = ball.y - targetHeight / 2;

        ctx.drawImage(ballImage, drawX, drawY, targetWidth, targetHeight);

    } else {
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, ball.size, 0, Math.PI * 2);
        let gradient = ctx.createRadialGradient(ball.x - 2, ball.y - 2, ball.size/4, ball.x, ball.y, ball.size);
        gradient.addColorStop(0, '#f39c12');
        gradient.addColorStop(1, '#d35400');
        ctx.fillStyle = gradient;
        ctx.fill();
        ctx.strokeStyle = "rgba(255,255,255,0.4)";
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.closePath();
    }
}


    // ç¹ªè£½æ¿å­
    function drawPaddle() {
        ctx.beginPath();
        ctx.roundRect(
    paddle.x,
    paddle.y, 
    paddle.width,
    paddle.height,
    10 * globalScale
);

        ctx.fillStyle = paddle.color;
        ctx.fill();
        ctx.shadowBlur = 10;
        ctx.shadowColor = "white";
        ctx.closePath();
        ctx.shadowBlur = 0;
    }

    // ç¹ªè£½ç—…æ¯’ç£šå¡Š
    function drawBricks() {
    for (let c = 0; c < brickConfig.columnCount; c++) {
        for (let r = 0; r < brickConfig.rowCount; r++) {
            if (bricks[c][r].status > 0) {
                // åŸæœ¬åŸºç¤ä½ç½®
                const baseX = (c * (brickConfig.width + brickConfig.padding)) + brickConfig.offsetLeft;
                const baseY = (r * (brickConfig.height + brickConfig.padding)) + brickConfig.offsetTop;

                // ç¬¬ 2 é—œé–‹å§‹å·¦å³ç§»å‹•ï¼ˆæ–°ï¼‰
                const brickX = baseX + (level >= 3 ? brickOffsetX : 0);
                const brickY = baseY;

                bricks[c][r].x = brickX;
                bricks[c][r].y = brickY;

                let centerX = brickX + brickConfig.width / 2;
                let centerY = brickY + brickConfig.height / 2;
                let radius = Math.min(brickConfig.width, brickConfig.height) / 2;

                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                ctx.fillStyle = bricks[c][r].color;
                ctx.fill();

                // ç—…æ¯’è§¸æ‰‹
                for(let i=0; i<8; i++) {
                    let angle = (i / 8) * Math.PI * 2;
                    let startX = centerX + Math.cos(angle) * (radius * 0.6);
                    let startY = centerY + Math.sin(angle) * (radius * 0.6);
                    let endX = centerX + Math.cos(angle) * (radius * 1.3);
                    let endY = centerY + Math.sin(angle) * (radius * 1.3);
                    
                    ctx.beginPath();
                    ctx.moveTo(startX, startY);
                    ctx.lineTo(endX, endY);
                    ctx.lineWidth = 3 * globalScale;
                    ctx.strokeStyle = bricks[c][r].color;
                    ctx.stroke();
                }

                if(bricks[c][r].status === 2) {
                    ctx.fillStyle = 'rgba(0,0,0,0.3)';
                    ctx.font = "16px Arial";
                    ctx.fillText("ğŸ’¢", centerX - 9, centerY + 6);
                }
                
                ctx.closePath();
            }
        }
    }
}


    // ç¢°æ’åµæ¸¬
    function collisionDetection() {
        for (let c = 0; c < brickConfig.columnCount; c++) {
            for (let r = 0; r < brickConfig.rowCount; r++) {
                const b = bricks[c][r];
                if (b.status > 0) {
                    if (ball.x > b.x && ball.x < b.x + brickConfig.width && ball.y > b.y && ball.y < b.y + brickConfig.height) {
                        ball.dy = -ball.dy;
                        b.status--; 
                        
                        if(b.status === 0) {
                            score += 10 * level; 
                            document.getElementById('scoreDisplay').innerText = `åˆ†æ•¸: ${score}`;
                            checkLevelClear();
                        } else {
                            score += 2;
                        }
                    }
                }
            }
        }
    }

    // æª¢æŸ¥æ˜¯å¦éé—œ
    function checkLevelClear() {
        let isCleared = true;
        for (let c = 0; c < brickConfig.columnCount; c++) {
            for (let r = 0; r < brickConfig.rowCount; r++) {
                if (bricks[c][r].status > 0) {
                    isCleared = false;
                    break;
                }
            }
        }

        if (isCleared) {
            if (level === maxLevels) {
                gameOver(true); 
            } else {
                level++;
                ball.speed += 0.5; 
                paddle.width *= 0.9; 
                document.getElementById('levelDisplay').innerText = `é—œå¡: ${level}/${maxLevels}`;
                resetBall();
                initBricks();
            }
        }
    }

    function resetBall() {
        ball.x = canvas.width / 2;
        ball.y = paddle.y - 30 * globalScale;
        
        let angle = (Math.random() * 45 + 45) * (Math.PI / 180); 
        if(Math.random() > 0.5) angle = 180 - angle; 

        let speed = (ball.speed + level * 0.5) * globalScale;
        ball.dx = speed * (Math.random() > 0.5 ? 1 : -1);
        ball.dy = -speed;

        
        paddle.x = (canvas.width - paddle.width) / 2;
    }

    function draw() {
        if (!gameRunning) return;

        ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (level >= 2) {
        brickOffsetX += brickMoveSpeed * brickDirection;

        // è¶…éå·¦å³æœ€å¤§ä½ç§»å°±åå‘
        if (brickOffsetX > brickMaxOffset || brickOffsetX < -brickMaxOffset) {
            brickDirection *= -1;
        }
    }

        drawBricks();
        drawBall(); // ç¾åœ¨æœƒç•«å‡ºå—åƒ‘æ°´æ™¶åœ–ç‰‡
        drawPaddle();
        collisionDetection();

        if (ball.x + ball.dx > canvas.width - ball.size || ball.x + ball.dx < ball.size) {
            ball.dx = -ball.dx;
        }
        if (ball.y + ball.dy < ball.size) {
            ball.dy = -ball.dy;
        } else if (ball.y + ball.dy > canvas.height - ball.size) {
            lives--;
            updateLivesDisplay();
            if (lives <= 0) {
                gameOver(false);
            } else {
                resetBall();
            }
        }

        if (ball.y + ball.dy + ball.size >= canvas.height - paddle.height - 10 && 
            ball.y + ball.dy - ball.size <= canvas.height - 10) {
            
            if (ball.x >= paddle.x && ball.x <= paddle.x + paddle.width) {
                let hitPoint = ball.x - (paddle.x + paddle.width / 2);
                hitPoint = hitPoint / (paddle.width / 2);
                let speed = Math.sqrt(ball.dx*ball.dx + ball.dy*ball.dy); 
                let angle = hitPoint * (Math.PI / 3); 
                ball.dx = speed * Math.sin(angle);
                ball.dy = -Math.abs(speed * Math.cos(angle)); 
            }
        }

        ball.x += ball.dx;
        ball.y += ball.dy;

        requestAnimationFrame(draw);
    }

    function updateLivesDisplay() {
        let hearts = "";
        for(let i=0; i<lives; i++) hearts += "â¤ï¸";
        document.getElementById('livesDisplay').innerText = `ç”Ÿå‘½: ${hearts}`;
    }

function startGame() {
    document.getElementById('start-screen').style.display = 'none';
    gameRunning = true;
    draw();
}


    function gameOver(win) {
        gameRunning = false;
        document.getElementById('end-screen').style.display = 'block';
        document.getElementById('final-score').innerText = score;
        const title = document.getElementById('end-title');
        
        if (win) {
            title.innerText = "ğŸ‰ æ­å–œé€šé—œï¼";
            title.style.color = "#e67e22";
        } else {
            title.innerText = "ğŸ˜­ ç—…æ¯’å¤ªå¼·äº†...";
            title.style.color = "#7f8c8d";
        }
    }

    function copyScore() {
        const text = `æˆ‘åœ¨å—åƒ‘æ°´æ™¶æ·¨åŒ–å¤§ä½œæˆ°ç²å¾—äº† ${score} åˆ†ï¼å¿«ä¾†æŒ‘æˆ°æˆ‘å§ï¼ #å—åƒ‘æ°´æ™¶ #æ¶ˆæ»…ç—…æ¯’`;
        navigator.clipboard.writeText(text).then(() => {
            const btn = document.querySelector('.btn-copy');
            btn.innerText = "å·²è¤‡è£½ï¼";
            setTimeout(() => btn.innerText = "è¤‡è£½æˆç¸¾ç•™è¨€", 2000);
        });
    }

    function movePaddle(clientX) {
        const relativeX = clientX - canvas.offsetLeft;
        if (relativeX > 0 && relativeX < canvas.width) {
            paddle.x = relativeX - paddle.width / 2;
        }
    }

    document.addEventListener("mousemove", (e) => {
        movePaddle(e.clientX);
    });

    document.addEventListener("touchmove", (e) => {
        e.preventDefault(); 
        movePaddle(e.touches[0].clientX);
    }, { passive: false });

    window.addEventListener('resize', resizeCanvas);

    resizeCanvas();

</script>

</body>
</html>